{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ProceX","text":"<p>Medical image datasets such as X-ray scans are typically stored in DICOM files, using signed 16-bit integers to represent pixel values. Typically, the DICOM files are converted to a different format, such as PNG or JPEG, and the pixel values are mapped to the full range of the output format and data type. There is not a standard method to preprocess the DICOM files to a format that can be used to train machine learning models. This causes variation across methods used in research works in the literature, which are often not described in detail and therefore not reproducible.</p> <p>ProceX is a Python package that provides a simple interface for converting DICOM files to a format that can be easily read and processed for machine learning tasks, encouraging best practices such as minimizing data loss and file size, and standardization across the field.</p> <p>ProceX is built on top of SimpleITK and may be used to enhance image contrast using different methods, resize images with different interpolatin techniques, and convert to a different format, all at once. Additionally, images can be processed in parallel using multiple CPU cores.</p> <p>ProceX also includes transforms to normalize pixel values of loaded images stored in 16 bits, so they are ready to be fed into a machine learning model.</p>"},{"location":"getting_help/","title":"Getting help","text":"<p>For bug reports or feature requests, please open an issue on the GitHub repository. For questions, open a discussion.</p>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>For now, you can install <code>procex</code> from GitHub. Soon, it will be available on PyPI.</p> uvpip <pre><code>uv add git+https://github.com/fepegar/procex\n</code></pre> <p>Note</p> <p>You can install uv with:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>pip install git+https://github.com/fepegar/procex\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>To get help, you can run <code>procex --help</code>.</p> uvpip <pre><code>uv run procex --help\n</code></pre> <p>Note</p> <p>To quickly try <code>procex</code> without installing it, use <code>uvx</code>:</p> <pre><code>uvx --from git+https://github.com/fepegar/procex procex --help\n</code></pre> <pre><code>procex --help\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"In\u00a0[1]: Copied! <pre>!procex --help\n</pre> !procex --help <pre>                                                                                \n Usage: procex [OPTIONS] INPUT OUTPUT                                           \n                                                                                \n Preprocess a medical image.                                                    \n                                                                                \n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    input       PATH  Path to the input image. If a text file is given,     \u2502\n\u2502                        process the image paths from the file. If a directory \u2502\n\u2502                        is given, process all files in the directory.         \u2502\n\u2502                        [default: None]                                       \u2502\n\u2502                        [required]                                            \u2502\n\u2502 *    output      PATH  Path to the output image. If a text file is given,    \u2502\n\u2502                        the output paths must be specified in the file. If a  \u2502\n\u2502                        directory is given, write the output images to the    \u2502\n\u2502                        directory.                                            \u2502\n\u2502                        [default: None]                                       \u2502\n\u2502                        [required]                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --size                             INTEGER           Size of the smaller     \u2502\n\u2502                                                      side of the output      \u2502\n\u2502                                                      image.                  \u2502\n\u2502                                                      [default: None]         \u2502\n\u2502 --num-bits                         [8|16]            Number of bits per      \u2502\n\u2502                                                      sample in the output    \u2502\n\u2502                                                      image.                  \u2502\n\u2502                                                      [default: 8]            \u2502\n\u2502 --jpeg-quality                     INTEGER           Compression quality for \u2502\n\u2502                                                      output JPEG images.     \u2502\n\u2502                                                      [default: 95]           \u2502\n\u2502 --percentiles                      &lt;FLOAT FLOAT&gt;...  Lower and upper         \u2502\n\u2502                                                      percentiles to clip the \u2502\n\u2502                                                      image intensity.        \u2502\n\u2502                                                      [default: 0, 100]       \u2502\n\u2502 --values                           &lt;FLOAT FLOAT&gt;...  Lower and upper values  \u2502\n\u2502                                                      to clip the image       \u2502\n\u2502                                                      intensity.              \u2502\n\u2502                                                      [default: None]         \u2502\n\u2502 --format                           TEXT              Output image format.    \u2502\n\u2502                                                      Only used when output   \u2502\n\u2502                                                      is a directory.         \u2502\n\u2502                                                      [default: None]         \u2502\n\u2502 --histeq          --no-histeq                        Whether to perform      \u2502\n\u2502                                                      histogram equalization  \u2502\n\u2502                                                      instead of intensity    \u2502\n\u2502                                                      range stretching.       \u2502\n\u2502                                                      [default: no-histeq]    \u2502\n\u2502 --mimic           --no-mimic                         Ignore all other        \u2502\n\u2502                                                      options and process as  \u2502\n\u2502                                                      in MIMIC-CXR-JPG.       \u2502\n\u2502                                                      [default: no-mimic]     \u2502\n\u2502 --parallel        --no-parallel                      Whether to process      \u2502\n\u2502                                                      images in parallel.     \u2502\n\u2502                                                      [default: no-parallel]  \u2502\n\u2502 --help                                               Show this message and   \u2502\n\u2502                                                      exit.                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>procex<ul> <li>functional</li> <li>imgio</li> <li>main</li> <li>plotting</li> <li>transforms</li> <li>type_definitions</li> </ul> </li> </ul>"},{"location":"reference/procex/","title":"procex","text":"<p>ProceX: A Python package for preprocessing medical images.</p>"},{"location":"reference/procex/#procex.__all__","title":"<code>__all__ = ['ToTensor', 'process_images']</code>  <code>module-attribute</code>","text":""},{"location":"reference/procex/#procex.__version__","title":"<code>__version__ = importlib.metadata.version(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/procex/#procex.ToTensor","title":"<code>ToTensor</code>","text":"<p>Convert an 8- or 16-bit Pillow image to a tensor and normalize to [0, 1].</p> Source code in <code>src/procex/transforms.py</code> <pre><code>class ToTensor:\n    \"\"\"Convert an 8- or 16-bit Pillow image to a tensor and normalize to [0, 1].\"\"\"\n    def __call__(self, image: Image.Image) -&gt; torch.Tensor:\n        \"\"\"Convert, cast and normalize the image.\n\n        Args:\n            image: The input image.\n\n        Returns:\n            The image as a tensor with shape (C, H, W) and dtype torch.float32.\n\n        Raises:\n            ImportError: If torch or torchvision are not installed.\n            ValueError: If the image dtype is not np.uint8 or np.uint16.\n        \"\"\"\n        try:\n            import torch\n            from torchvision.transforms import _functional_pil as F_pil\n        except ImportError as e:\n            message = (\n                \"ToTensorEightOrSixteenBits requires extra packages to be installed.\"\n                \" Install with `pip install procex[torch]`.\"\n            )\n            raise ImportError(message) from e\n\n        array = np.array(image)\n        match array.dtype:\n            case np.uint8:\n                num_bits = 8\n            case np.uint16:\n                num_bits = 16\n            case _:\n                message = f\"Unsupported dtype: {array.dtype}\"\n                raise ValueError(message)\n        array = array.astype(np.float32) / 2 ** num_bits - 1\n        # The following lines were adapted from\n        # https://pytorch.org/vision/main/_modules/torchvision/transforms/functional.html#to_tensor\n        tensor = torch.from_numpy(array)\n        num_channels = F_pil.get_image_num_channels(image)\n        tensor = tensor.view(image.size[1], image.size[0], num_channels)\n        return tensor.permute((2, 0, 1)).contiguous()\n</code></pre>"},{"location":"reference/procex/#procex.ToTensor.__call__","title":"<code>__call__(image)</code>","text":"<p>Convert, cast and normalize the image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The image as a tensor with shape (C, H, W) and dtype torch.float32.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If torch or torchvision are not installed.</p> <code>ValueError</code> <p>If the image dtype is not np.uint8 or np.uint16.</p> Source code in <code>src/procex/transforms.py</code> <pre><code>def __call__(self, image: Image.Image) -&gt; torch.Tensor:\n    \"\"\"Convert, cast and normalize the image.\n\n    Args:\n        image: The input image.\n\n    Returns:\n        The image as a tensor with shape (C, H, W) and dtype torch.float32.\n\n    Raises:\n        ImportError: If torch or torchvision are not installed.\n        ValueError: If the image dtype is not np.uint8 or np.uint16.\n    \"\"\"\n    try:\n        import torch\n        from torchvision.transforms import _functional_pil as F_pil\n    except ImportError as e:\n        message = (\n            \"ToTensorEightOrSixteenBits requires extra packages to be installed.\"\n            \" Install with `pip install procex[torch]`.\"\n        )\n        raise ImportError(message) from e\n\n    array = np.array(image)\n    match array.dtype:\n        case np.uint8:\n            num_bits = 8\n        case np.uint16:\n            num_bits = 16\n        case _:\n            message = f\"Unsupported dtype: {array.dtype}\"\n            raise ValueError(message)\n    array = array.astype(np.float32) / 2 ** num_bits - 1\n    # The following lines were adapted from\n    # https://pytorch.org/vision/main/_modules/torchvision/transforms/functional.html#to_tensor\n    tensor = torch.from_numpy(array)\n    num_channels = F_pil.get_image_num_channels(image)\n    tensor = tensor.view(image.size[1], image.size[0], num_channels)\n    return tensor.permute((2, 0, 1)).contiguous()\n</code></pre>"},{"location":"reference/procex/#procex.process_images","title":"<code>process_images(input, output, size=None, num_bits=NumBits.EIGHT, jpeg_quality=95, percentiles=(0, 100), values=None, format=None, *, histeq=False, mimic=False, parallel=False)</code>","text":"<p>Preprocess a medical image.</p> Source code in <code>src/procex/main.py</code> <pre><code>@_app.command()\ndef process_images(  # noqa: PLR0913\n    input: Annotated[  # noqa: A002\n        Path,\n        typer.Argument(\n            ...,\n            help=(\n                \"Path to the input image. If a text file is given, process the image\"\n                \" paths from the file. If a directory is given, process all files in\"\n                \" the directory.\"\n            ),\n        ),\n    ],\n    output: Annotated[\n        Path,\n        typer.Argument(\n            ...,\n            help=(\n                \"Path to the output image. If a text file is given, the output paths\"\n                \" must be specified in the file. If a directory is given, write the\"\n                \" output images to the directory.\"\n            ),\n        ),\n    ],\n    size: Annotated[\n        int | None,\n        typer.Option(\n            ...,\n            help=\"Size of the smaller side of the output image.\",\n        ),\n    ] = None,\n    num_bits: Annotated[\n        NumBits,\n        typer.Option(\n            ...,\n            help=\"Number of bits per sample in the output image.\",\n        ),\n    ] = NumBits.EIGHT,\n    jpeg_quality: Annotated[\n        int,\n        typer.Option(\n            ...,\n            help=\"Compression quality for output JPEG images.\",\n            callback=check_quality,\n        ),\n    ] = 95,\n    percentiles: Annotated[\n        tuple[float, float],\n        typer.Option(\n            ...,\n            help=\"Lower and upper percentiles to clip the image intensity.\",\n        ),\n    ] = (0, 100),\n    values: Annotated[\n        tuple[float, float] | None,\n        typer.Option(\n            ...,\n            help=\"Lower and upper values to clip the image intensity.\",\n        ),\n    ] = None,\n    format: Annotated[  # noqa: A002\n        str | None,\n        typer.Option(\n            ...,\n            help=\"Output image format. Only used when output is a directory.\",\n        ),\n    ] = None,\n    *,\n    histeq: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=(\n                \"Whether to perform histogram equalization instead of intensity range\"\n                \" stretching.\"\n            ),\n        ),\n    ] = False,\n    mimic: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=\"Ignore all other options and process as in MIMIC-CXR-JPG.\",\n        ),\n    ] = False,\n    parallel: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=\"Whether to process images in parallel.\",\n        ),\n    ] = False,\n) -&gt; None:\n    \"\"\"Preprocess a medical image.\"\"\"\n    input_paths = _get_input_paths(input)\n    output_paths = _get_output_paths(output, input_paths, format=format)\n\n    _process = partial(\n        _process_image,\n        size=size,\n        num_bits=num_bits,\n        jpeg_quality=jpeg_quality,\n        percentiles=percentiles,\n        values=values,\n        histeq=histeq,\n        mimic=mimic,\n    )\n\n    if parallel:\n        process_map(_process, input_paths, output_paths, chunksize=1)\n        return\n\n    if len(input_paths) &gt; 1:\n        progress = tqdm(list(zip(input_paths, output_paths, strict=True)))\n        for input_path, output_path in progress:\n            _process(input_path, output_path)\n    else:\n        _process(input_paths[0], output_paths[0])\n</code></pre>"},{"location":"reference/procex/functional/","title":"functional","text":"<p>Low-level image processing operations.</p>"},{"location":"reference/procex/functional/#procex.functional.enhance_contrast","title":"<code>enhance_contrast(image, *, num_bits=None, percentiles=(0, 100), values=None, histeq=False)</code>","text":"<p>Stretch the intensity range of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>Input image.</p> required <code>num_bits</code> <code>int | None</code> <p>Number of bits used to represent the image intensity.</p> <code>None</code> <code>percentiles</code> <code>tuple[float, float]</code> <p>Lower and upper percentiles to clip the image intensity.</p> <code>(0, 100)</code> <code>values</code> <code>tuple[float, float] | None</code> <p>Lower and upper values to clip the image intensity.</p> <code>None</code> <code>histeq</code> <code>bool</code> <p>Whether to perform histogram equalization instead of intensity range stretching.</p> <code>False</code> <p>Returns:</p> Type Description <code>Image</code> <p>The output image with the intensity range stretched.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the pixel type is not supported.</p> Source code in <code>src/procex/functional.py</code> <pre><code>def enhance_contrast(\n    image: sitk.Image,\n    *,\n    num_bits: int | None = None,\n    percentiles: tuple[float, float] = (0, 100),\n    values: tuple[float, float] | None = None,\n    histeq: bool = False,\n) -&gt; sitk.Image:\n    \"\"\"Stretch the intensity range of an image.\n\n    Args:\n        image: Input image.\n        num_bits: Number of bits used to represent the image intensity.\n        percentiles: Lower and upper percentiles to clip the image intensity.\n        values: Lower and upper values to clip the image intensity.\n        histeq: Whether to perform histogram equalization instead of intensity\n            range stretching.\n\n    Returns:\n        The output image with the intensity range stretched.\n\n    Raises:\n        NotImplementedError: If the pixel type is not supported.\n    \"\"\"\n    if num_bits is None:\n        match image.GetPixelIDValue():\n            case sitk.sitkUInt8:\n                num_bits = 8\n            case sitk.sitkUInt16:\n                num_bits = 16\n            case _:\n                pixel_type_string = image.GetPixelIDTypeAsString()\n                msg = f'Unsupported pixel type \"{pixel_type_string}\"'\n                raise NotImplementedError(msg)\n    image = sitk.Cast(image, sitk.sitkFloat32)\n    if histeq:\n        stretched = _histogram_equalization(image, num_bits)\n    else:\n        if values is not None:\n            image = sitk.Clamp(image, image.GetPixelID(), *values)\n        if percentiles != (0, 100):\n            image = _clip(image, percentiles)\n        minimum = 0\n        maximum = 2**num_bits - 1\n        stretched = sitk.RescaleIntensity(image, minimum, maximum)\n    out_dtype = getattr(sitk, f\"sitkUInt{num_bits}\")\n    return sitk.Cast(stretched, out_dtype)\n</code></pre>"},{"location":"reference/procex/functional/#procex.functional.resize","title":"<code>resize(image, size, *, interpolator=sitk.sitkBSpline, smooth=True, keep_aspect_ratio=True)</code>","text":"<p>Resize an image to a specified size.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image.</p> required <code>size</code> <code>int</code> <p>The size of the output image.</p> required <code>interpolator</code> <code>int</code> <p>The interpolation method.</p> <code>sitkBSpline</code> <code>smooth</code> <code>bool</code> <p>Whether to smooth the image before downsampling.</p> <code>True</code> <code>keep_aspect_ratio</code> <code>bool</code> <p>Whether to keep the aspect ratio of the image.</p> <code>True</code> <p>Returns:</p> Type Description <code>Image</code> <p>The output image resized to the specified size.</p> Source code in <code>src/procex/functional.py</code> <pre><code>def resize(\n    image: sitk.Image,\n    size: int,\n    *,\n    interpolator: int = sitk.sitkBSpline,\n    smooth: bool = True,\n    keep_aspect_ratio: bool = True,\n) -&gt; sitk.Image:\n    \"\"\"Resize an image to a specified size.\n\n    Args:\n        image: The input image.\n        size: The size of the output image.\n        interpolator: The interpolation method.\n        smooth: Whether to smooth the image before downsampling.\n        keep_aspect_ratio: Whether to keep the aspect ratio of the image.\n\n    Returns:\n        The output image resized to the specified size.\n    \"\"\"\n    if not keep_aspect_ratio:\n        msg = \"Non-uniform scaling is not supported yet\"\n        raise NotImplementedError(msg)\n\n    input_size = image.GetSize()\n    image_spacing = image.GetSpacing()\n    max_dim = max(input_size)\n    scale_factor = max_dim / size\n    input_dtype = image.GetPixelID()\n    input_min, input_max = sitk.MinimumMaximum(image)\n\n    if smooth and scale_factor &lt; 1:\n        image = _smooth(image, scale_factor)\n\n    new_size = np.array(input_size) / scale_factor\n    new_size = np.round(new_size).astype(int).tolist()\n    new_spacing = np.array(image_spacing) * scale_factor\n\n    resized = sitk.Resample(\n        image,\n        size=new_size,\n        interpolator=interpolator,\n        outputSpacing=tuple(new_spacing),\n        outputOrigin=image.GetOrigin(),\n        outputDirection=image.GetDirection(),\n    )\n    # Clamp the intensity values to the original range as some interpolators\n    # may produce out-of-range values\n    resized = sitk.Clamp(resized, input_dtype, input_min, input_max)\n    return sitk.Cast(resized, input_dtype)\n</code></pre>"},{"location":"reference/procex/functional/#procex.functional.rgb2gray","title":"<code>rgb2gray(image)</code>","text":"<p>Convert an RGB image to grayscale.</p> <p>If the input image is a single channel image, it is returned as is. If the input image is a multi-channel image, the channels are assumed to contain the same data, and the first channel is returned as a single channel image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image with 3 channels.</p> required <p>Returns:</p> Type Description <code>Image</code> <p>The output image with a single channel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the channels contain different data.</p> Source code in <code>src/procex/functional.py</code> <pre><code>def rgb2gray(image: sitk.Image) -&gt; sitk.Image:\n    \"\"\"Convert an RGB image to grayscale.\n\n    If the input image is a single channel image, it is returned as is. If the\n    input image is a multi-channel image, the channels are assumed to contain\n    the same data, and the first channel is returned as a single channel image.\n\n    Args:\n        image: The input image with 3 channels.\n\n    Returns:\n        The output image with a single channel.\n\n    Raises:\n        ValueError: If the channels contain different data.\n    \"\"\"\n    num_channels = image.GetNumberOfComponentsPerPixel()\n    if num_channels == 1:\n        return image\n    channels = [\n        sitk.VectorIndexSelectionCast(image, channel) for channel in range(num_channels)\n    ]\n    # Verify all channels contain the same data\n    for channel in channels[1:]:\n        if sitk.Hash(channel) != sitk.Hash(channels[0]):\n            msg = \"RGB images are expected to have identical channels\"\n            raise ValueError(msg)\n    return channels[0]\n</code></pre>"},{"location":"reference/procex/functional/#procex.functional.squeeze","title":"<code>squeeze(image)</code>","text":"<p>Remove singleton dimensions from the image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image.</p> required Source code in <code>src/procex/functional.py</code> <pre><code>def squeeze(image: sitk.Image) -&gt; sitk.Image:\n    \"\"\"Remove singleton dimensions from the image.\n\n    Args:\n        image: The input image.\n    \"\"\"\n    try:\n        singleton_dim = image.GetSize().index(1)\n    except ValueError:\n        return image\n    slices = [slice(None)] * image.GetDimension()\n    slices[singleton_dim] = 0\n    return image[slices]\n</code></pre>"},{"location":"reference/procex/imgio/","title":"imgio","text":"<p>Input/output utilities for image processing.</p>"},{"location":"reference/procex/imgio/#procex.imgio.ItkImageIo","title":"<code>ItkImageIo</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of ITK image IO classes.</p> Source code in <code>src/procex/imgio.py</code> <pre><code>@enum.unique\nclass ItkImageIo(str, enum.Enum):\n    \"\"\"Enumeration of ITK image IO classes.\"\"\"\n\n    JPEG = \"JPEGImageIO\"\n    JPEG_2000 = \"JPEG2000ImageIO\"\n    PNG = \"PNGImageIO\"\n    TIFF = \"TIFFImageIO\"\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.ItkImageIo.JPEG","title":"<code>JPEG = 'JPEGImageIO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/imgio/#procex.imgio.ItkImageIo.JPEG_2000","title":"<code>JPEG_2000 = 'JPEG2000ImageIO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/imgio/#procex.imgio.ItkImageIo.PNG","title":"<code>PNG = 'PNGImageIO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/imgio/#procex.imgio.ItkImageIo.TIFF","title":"<code>TIFF = 'TIFFImageIO'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/imgio/#procex.imgio.check_quality","title":"<code>check_quality(value)</code>","text":"<p>Check that a value is a valid quality for JPEG compression.</p> Source code in <code>src/procex/imgio.py</code> <pre><code>def check_quality(value: int) -&gt; int:\n    \"\"\"Check that a value is a valid quality for JPEG compression.\"\"\"\n    min_quality = 0\n    max_quality = 100\n    if not (min_quality &lt;= value &lt;= max_quality):\n        message = f\"Quality must be an integer between 0 and 100 but got {value}.\"\n        raise ValueError(message)\n    return value\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.check_uint8","title":"<code>check_uint8(func)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>def check_uint8(func: Callable) -&gt; Callable:\n    def wrapper(\n        image: sitk.Image,\n        path: TypePath,\n        *args,\n        **kwargs,\n    ) -&gt; None:\n        if image.GetPixelID() != sitk.sitkUInt8:\n            msg = (\n                f'Expected image \"{path}\" to have pixel type \"8-bit unsigned integer\",'\n                f' but got \"{image.GetPixelIDTypeAsString()}\"'\n            )\n            raise ValueError(msg)\n        return func(image, path, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.read_image","title":"<code>read_image(path, *, squeeze=True, grayscale=True)</code>","text":"<p>Read an image from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>TypePath</code> <p>The path to the image file.</p> required <code>squeeze</code> <code>bool</code> <p>Whether to remove singleton dimensions from the image.</p> <code>True</code> <code>grayscale</code> <code>bool</code> <p>Whether to convert the image to single-channel grayscale.</p> <code>True</code> <p>Returns:</p> Type Description <code>Image</code> <p>The image read from the file</p> Source code in <code>src/procex/imgio.py</code> <pre><code>def read_image(\n    path: TypePath,\n    *,\n    squeeze: bool = True,\n    grayscale: bool = True,\n) -&gt; sitk.Image:\n    \"\"\"Read an image from a file.\n\n    Args:\n        path: The path to the image file.\n        squeeze: Whether to remove singleton dimensions from the image.\n        grayscale: Whether to convert the image to single-channel grayscale.\n\n    Returns:\n        The image read from the file\n    \"\"\"\n    image = sitk.ReadImage(str(path))\n    if grayscale:\n        image = rgb2gray(image)\n    if squeeze:\n        image = squeeze_image(image)\n    return image\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.write_image","title":"<code>write_image(image, path)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>def write_image(\n    image: sitk.Image,\n    path: TypePath,\n) -&gt; None:\n    sitk.WriteImage(image, str(path))\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.write_jpeg","title":"<code>write_jpeg(image, path, quality=95)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>@check_uint8\ndef write_jpeg(\n    image: sitk.Image,\n    path: TypePath,\n    quality: int = 95,  # default in ITK: https://github.com/InsightSoftwareConsortium/ITK/blob/15af3aed65693811448c9af22ce9d09ff9f3000a/Modules/IO/JPEG/src/itkJPEGImageIO.cxx#L300\n) -&gt; None:\n    _check_suffix(path, (\".jpg\", \".jpeg\"))\n    writer = sitk.ImageFileWriter()\n    writer.SetImageIO(ItkImageIo.JPEG.value)\n    writer.SetCompressionLevel(quality)\n    writer.SetFileName(str(path))\n    writer.Execute(image)\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.write_jpeg_2000","title":"<code>write_jpeg_2000(image, path)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>def write_jpeg_2000(\n    image: sitk.Image,\n    path: TypePath,\n) -&gt; None:\n    _check_suffix(path, \".jp2\")\n    write_image(image, path)\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.write_png","title":"<code>write_png(image, path)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>def write_png(\n    image: sitk.Image,\n    path: TypePath,\n) -&gt; None:\n    _check_suffix(path, \".png\")\n    write_image(image, path)\n</code></pre>"},{"location":"reference/procex/imgio/#procex.imgio.write_tiff","title":"<code>write_tiff(image, path)</code>","text":"Source code in <code>src/procex/imgio.py</code> <pre><code>def write_tiff(\n    image: sitk.Image,\n    path: TypePath,\n) -&gt; None:\n    _check_suffix(path, (\".tif\", \".tiff\"))\n    write_image(image, path)\n</code></pre>"},{"location":"reference/procex/main/","title":"main","text":"<p>Main entry point for the procex command-line interface.</p>"},{"location":"reference/procex/main/#procex.main.disable_rich","title":"<code>disable_rich = os.environ.get('PROCEX_DISABLE_RICH', '0') == '1'</code>  <code>module-attribute</code>","text":""},{"location":"reference/procex/main/#procex.main.rich_kwargs","title":"<code>rich_kwargs = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/procex/main/#procex.main.NumBits","title":"<code>NumBits</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Number of bits per sample in the output image.</p> Source code in <code>src/procex/main.py</code> <pre><code>class NumBits(str, Enum):\n    \"\"\"Number of bits per sample in the output image.\"\"\"\n\n    EIGHT = \"8\"\n    SIXTEEN = \"16\"\n</code></pre>"},{"location":"reference/procex/main/#procex.main.NumBits.EIGHT","title":"<code>EIGHT = '8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/main/#procex.main.NumBits.SIXTEEN","title":"<code>SIXTEEN = '16'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/procex/main/#procex.main.process_images","title":"<code>process_images(input, output, size=None, num_bits=NumBits.EIGHT, jpeg_quality=95, percentiles=(0, 100), values=None, format=None, *, histeq=False, mimic=False, parallel=False)</code>","text":"<p>Preprocess a medical image.</p> Source code in <code>src/procex/main.py</code> <pre><code>@_app.command()\ndef process_images(  # noqa: PLR0913\n    input: Annotated[  # noqa: A002\n        Path,\n        typer.Argument(\n            ...,\n            help=(\n                \"Path to the input image. If a text file is given, process the image\"\n                \" paths from the file. If a directory is given, process all files in\"\n                \" the directory.\"\n            ),\n        ),\n    ],\n    output: Annotated[\n        Path,\n        typer.Argument(\n            ...,\n            help=(\n                \"Path to the output image. If a text file is given, the output paths\"\n                \" must be specified in the file. If a directory is given, write the\"\n                \" output images to the directory.\"\n            ),\n        ),\n    ],\n    size: Annotated[\n        int | None,\n        typer.Option(\n            ...,\n            help=\"Size of the smaller side of the output image.\",\n        ),\n    ] = None,\n    num_bits: Annotated[\n        NumBits,\n        typer.Option(\n            ...,\n            help=\"Number of bits per sample in the output image.\",\n        ),\n    ] = NumBits.EIGHT,\n    jpeg_quality: Annotated[\n        int,\n        typer.Option(\n            ...,\n            help=\"Compression quality for output JPEG images.\",\n            callback=check_quality,\n        ),\n    ] = 95,\n    percentiles: Annotated[\n        tuple[float, float],\n        typer.Option(\n            ...,\n            help=\"Lower and upper percentiles to clip the image intensity.\",\n        ),\n    ] = (0, 100),\n    values: Annotated[\n        tuple[float, float] | None,\n        typer.Option(\n            ...,\n            help=\"Lower and upper values to clip the image intensity.\",\n        ),\n    ] = None,\n    format: Annotated[  # noqa: A002\n        str | None,\n        typer.Option(\n            ...,\n            help=\"Output image format. Only used when output is a directory.\",\n        ),\n    ] = None,\n    *,\n    histeq: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=(\n                \"Whether to perform histogram equalization instead of intensity range\"\n                \" stretching.\"\n            ),\n        ),\n    ] = False,\n    mimic: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=\"Ignore all other options and process as in MIMIC-CXR-JPG.\",\n        ),\n    ] = False,\n    parallel: Annotated[\n        bool,\n        typer.Option(\n            ...,\n            help=\"Whether to process images in parallel.\",\n        ),\n    ] = False,\n) -&gt; None:\n    \"\"\"Preprocess a medical image.\"\"\"\n    input_paths = _get_input_paths(input)\n    output_paths = _get_output_paths(output, input_paths, format=format)\n\n    _process = partial(\n        _process_image,\n        size=size,\n        num_bits=num_bits,\n        jpeg_quality=jpeg_quality,\n        percentiles=percentiles,\n        values=values,\n        histeq=histeq,\n        mimic=mimic,\n    )\n\n    if parallel:\n        process_map(_process, input_paths, output_paths, chunksize=1)\n        return\n\n    if len(input_paths) &gt; 1:\n        progress = tqdm(list(zip(input_paths, output_paths, strict=True)))\n        for input_path, output_path in progress:\n            _process(input_path, output_path)\n    else:\n        _process(input_paths[0], output_paths[0])\n</code></pre>"},{"location":"reference/procex/plotting/","title":"plotting","text":"<p>Functions to plot images and histograms.</p>"},{"location":"reference/procex/plotting/#procex.plotting.plot_histogram","title":"<code>plot_histogram(image, ax=None, *, log=True)</code>","text":"Source code in <code>src/procex/plotting.py</code> <pre><code>def plot_histogram(\n    image: sitk.Image,\n    ax: Axes | None = None,\n    *,\n    log: bool = True,\n) -&gt; None:\n    if ax is None:\n        _, ax = plt.subplots()\n    array = sitk.GetArrayViewFromImage(image)\n    ax.hist(array.ravel(), bins=256)\n    if log:\n        ax.set_yscale(\"log\")\n</code></pre>"},{"location":"reference/procex/plotting/#procex.plotting.plot_image","title":"<code>plot_image(image, ax=None)</code>","text":"Source code in <code>src/procex/plotting.py</code> <pre><code>def plot_image(image: sitk.Image, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        _, ax = plt.subplots()\n    array = sitk.GetArrayViewFromImage(image)\n    ax.imshow(array, cmap=\"gray\")\n</code></pre>"},{"location":"reference/procex/transforms/","title":"transforms","text":"<p>Transforms to preprocess images for training and inference.</p>"},{"location":"reference/procex/transforms/#procex.transforms.ToTensor","title":"<code>ToTensor</code>","text":"<p>Convert an 8- or 16-bit Pillow image to a tensor and normalize to [0, 1].</p> Source code in <code>src/procex/transforms.py</code> <pre><code>class ToTensor:\n    \"\"\"Convert an 8- or 16-bit Pillow image to a tensor and normalize to [0, 1].\"\"\"\n    def __call__(self, image: Image.Image) -&gt; torch.Tensor:\n        \"\"\"Convert, cast and normalize the image.\n\n        Args:\n            image: The input image.\n\n        Returns:\n            The image as a tensor with shape (C, H, W) and dtype torch.float32.\n\n        Raises:\n            ImportError: If torch or torchvision are not installed.\n            ValueError: If the image dtype is not np.uint8 or np.uint16.\n        \"\"\"\n        try:\n            import torch\n            from torchvision.transforms import _functional_pil as F_pil\n        except ImportError as e:\n            message = (\n                \"ToTensorEightOrSixteenBits requires extra packages to be installed.\"\n                \" Install with `pip install procex[torch]`.\"\n            )\n            raise ImportError(message) from e\n\n        array = np.array(image)\n        match array.dtype:\n            case np.uint8:\n                num_bits = 8\n            case np.uint16:\n                num_bits = 16\n            case _:\n                message = f\"Unsupported dtype: {array.dtype}\"\n                raise ValueError(message)\n        array = array.astype(np.float32) / 2 ** num_bits - 1\n        # The following lines were adapted from\n        # https://pytorch.org/vision/main/_modules/torchvision/transforms/functional.html#to_tensor\n        tensor = torch.from_numpy(array)\n        num_channels = F_pil.get_image_num_channels(image)\n        tensor = tensor.view(image.size[1], image.size[0], num_channels)\n        return tensor.permute((2, 0, 1)).contiguous()\n</code></pre>"},{"location":"reference/procex/transforms/#procex.transforms.ToTensor.__call__","title":"<code>__call__(image)</code>","text":"<p>Convert, cast and normalize the image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>The input image.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The image as a tensor with shape (C, H, W) and dtype torch.float32.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If torch or torchvision are not installed.</p> <code>ValueError</code> <p>If the image dtype is not np.uint8 or np.uint16.</p> Source code in <code>src/procex/transforms.py</code> <pre><code>def __call__(self, image: Image.Image) -&gt; torch.Tensor:\n    \"\"\"Convert, cast and normalize the image.\n\n    Args:\n        image: The input image.\n\n    Returns:\n        The image as a tensor with shape (C, H, W) and dtype torch.float32.\n\n    Raises:\n        ImportError: If torch or torchvision are not installed.\n        ValueError: If the image dtype is not np.uint8 or np.uint16.\n    \"\"\"\n    try:\n        import torch\n        from torchvision.transforms import _functional_pil as F_pil\n    except ImportError as e:\n        message = (\n            \"ToTensorEightOrSixteenBits requires extra packages to be installed.\"\n            \" Install with `pip install procex[torch]`.\"\n        )\n        raise ImportError(message) from e\n\n    array = np.array(image)\n    match array.dtype:\n        case np.uint8:\n            num_bits = 8\n        case np.uint16:\n            num_bits = 16\n        case _:\n            message = f\"Unsupported dtype: {array.dtype}\"\n            raise ValueError(message)\n    array = array.astype(np.float32) / 2 ** num_bits - 1\n    # The following lines were adapted from\n    # https://pytorch.org/vision/main/_modules/torchvision/transforms/functional.html#to_tensor\n    tensor = torch.from_numpy(array)\n    num_channels = F_pil.get_image_num_channels(image)\n    tensor = tensor.view(image.size[1], image.size[0], num_channels)\n    return tensor.permute((2, 0, 1)).contiguous()\n</code></pre>"},{"location":"reference/procex/type_definitions/","title":"type_definitions","text":"<p>Typing definitions for ProceX.</p>"},{"location":"reference/procex/type_definitions/#procex.type_definitions.TypePath","title":"<code>TypePath = os.PathLike | str</code>  <code>module-attribute</code>","text":""},{"location":"scripts/gen_ref_pages/","title":"Gen ref pages","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages.\n\nAdapted from\nhttps://mkdocstrings.github.io/recipes/#generate-pages-on-the-fly.\n\"\"\"\n</pre> \"\"\"Generate the code reference pages.  Adapted from https://mkdocstrings.github.io/recipes/#generate-pages-on-the-fly. \"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.nav.Nav()\nsrc = Path(__file__).parent.parent.parent / \"src\"\n</pre> nav = mkdocs_gen_files.nav.Nav() src = Path(__file__).parent.parent.parent / \"src\" In\u00a0[\u00a0]: Copied! <pre>for path in sorted(src.rglob(\"*.py\")):\n    module_path = path.relative_to(src).with_suffix(\"\")\n    doc_path = path.relative_to(src).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(src.rglob(\"*.py\")):     module_path = path.relative_to(src).with_suffix(\"\")     doc_path = path.relative_to(src).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}